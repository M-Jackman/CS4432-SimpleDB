The replacement policies uses an array of integers. Each number at an index corresponds to the
buffer at that index. That way, the buffers themselves are not being accessed in any way, only
a separate entity is. Any changes in the array of buffers is reflected in these arrays so that, 
when it comes time to replace a buffer, the appropriate buffer is changed.

Least Recently Used originally sets all of the numbers in its array to 0, meaning that there
is nothing there at that index. If there's a -1, that means that there is something in the buffer
at that index, but it is pinned so it cannot be replaced. If there is a number that is greater
than 0 in this array, it means the buffer at that location is unpinned and can be replaced. 
Every time a buffer is added, pinned, or unpinned, every buffer that is unpinned has their 
value in the index array incremented by 1. A larger number means that this buffer is more likely
to be removed when there is no more space. When a replacement is needed, the index array is then 
searched to find the largest number in it, and when it does, returns the buffer/index of the 
buffer to be removed.  If all the buffers are pinned, it returns -1 meaning nothing can be replaced

Clock Replacement starts similarly to Least Recently Used by setting all of its numbers in its
array to 0. Whenever a buffer is pinned, the value in the array at that buffer's index is set
to -1, just like in least recently used. However, unlike in least recently used,, where the 
values can go to infinity, it only can have two other values, 1 & 2. If it is a 1, that means
there is a chance the data can get sent back to the disk. If it's a 2, that means there's less
of a chance the data gets sent back. There is also another value called clockHand which starts 
at 0 and is used to see which buffer is currently being pointed at. This value only changes 
when the replacement policy is being used or a new buffer is added. It will increment by 1 until
its value is equal to the number of buffers. If that is the case, then it has to start from the
first buffer, so its value is reset to 0. The clock replacement policy checks if the current 
buffer the clock hand is on is unpinned. If it isn't, then it checks if the value is a 1 or 2. 
If it is a 1, that means this buffer can be removed and a new buffer can take it's place. If 
not, then it has to check all of the other buffers before it returns back to the buffer the 
clock hand started at and finds out that the information in the buffer can be replaced. However,
if any other index values it checks has a value of 1, that buffer can be removed and it/its
index is returned. If all of the buffers are pinned, it returns -1 meaning nothing can be replaced